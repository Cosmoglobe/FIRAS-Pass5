	Program frd_dgtl_transfcn
c 
c  This routine creates the data file DGTL_TRANSFCN.DAT containing the
c  digital part of the FIRAS post-detector electronics transfer function,
c  using the analytical expressions for the digital lowpass filter, and the
c  smoothing due to data compression. Its record format and file structure
c  is identical to the files generated by program ELEX_TRANSFCN, so the
c  routine FUT_GET_RECNUM can be used to retrieve data from either file. 
c
c  Each record of the output file is an array of 257 complex*8 numbers
c  representing the complex transfer function for a particular scan mode at
c  frequencies ranging from DC up to the Nyquist frequency associated with
c  the data compression.
c
c  There are 288 records in an unformatted direct-access output file. These
c  are:
c		3 sample rates (fakeit, fast scan, and slow scan)
c	    x	4 channels
c	    x   2 microprocessor science modes (digital filters on or off)
c	    x  12 possible amounts of data compression ("adds per group" =1to12)
c
c  Written by Rich Isaacman (Applied Research Corp.)
c  Modified 7 July 1986 to make DC gain 240 instead of 100 per measurement
c  Modified 28 October 1987 to treat all four channels separately and
c	update digital filters and fixed gain.
c  Modified by J.T.Bonnell (STX@GSFC) nov.1988
c		brought up to standards under spr 1814
c  Modified by R.Kummerer (STX@GSFC) may 1989 Remove useless TYPE statement.
c  SPR 5291, Generate digital transfer function for new sampling rate.
c		R. Kummerer, Dec 15, 1989, STX@GSFC.
c  Updated the code to read new FEX_SAMPRATE text file. SPR 9846.
c               Nilo G. Gonzales/Hughes STX, July 31, 1992.
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

	implicit none

	include '($ssdef)'
	include '(upm_stat_msg)'

	complex *8	ztrans(257)
	complex *8	zbesl
	complex *8	ztboost
	complex *8	zdcblock
	complex *8	zdigfil
	complex *8	zsmooth
	complex *8	zanalog
	complex *8	zdigital
	complex *8	zxfer

	integer *4	status
	integer *4      upm_stat
	integer *4	ios
	integer *4	lun, lun_samp
	integer *4	nrec
	integer *4	isampl
	integer *4	ichan
	integer *4	micro
	integer *4	ncompress
	integer *4	k
	integer *2      len
	logical *1      mission /.false./, int /.false./
	character *16   in_file /'fex_samprate.txt'/
	character *11	out_file /'fex_dtf.dat'/
	character *6    sample
	character *7    qual
	real *4         int_samp_hz(3)                  !INT data
	real *4		mis_samp_hz(3)                  !Mission data

	real *4		tau(4)                      
	data tau /0.00647,				!RH treble boost
     .		  0.03619,				!RL   "     "
     .		  0.00722,				!LH   "     "
     .		  0.04022/				!LL   "     "

	real *4		bes3db
	parameter (bes3db = 100.)			!Bessel corner freq
	real *4		fixed_gain
	parameter (fixed_gain = 31. * 1.3823)		!Preamp fixed gain
	real *4		bessel_gain
	parameter (bessel_gain = 1.2255 * 1.9099)	!Bessel DC gain

	real *4		dcgain
	real *4		fsamp
	real *4		tauboost
	real *4		dfhz
	real *4		ampl
	real *4		ampmax
	real *4		freqhz

	integer *4	lib$get_lun
	integer *4	lib$free_lun
	integer *4      upm_present
	integer *4      upm_get_value

	external	frd_normal
	external	frd_rmsopen
	external	frd_rmswrite
	external	frd_rmsclose

c Parse the command line.

	if (upm_present('sample') .eq. upm_pres) then
           upm_stat = upm_get_value('sample',qual,len)
	   if (upm_stat .ne. ss$_normal) then
	      call lib$signal (%val(ss$_abort))
	   end if
	   if (qual .eq. 'INT') then
	      int = .true.
	   else 
	      mission = .true.
	   end if
	end if	
c
c open fex_samprate text file for mtm sampling rate (INT, or MISSION) 
c
	status = lib$get_lun(lun_samp)
	if (status .eq. ss$_normal) then
	   open (unit=lun_samp, name=in_file, status='old',
     .	         iostat=ios, readonly, shared)
	      if (ios .ne. 0) then
	         status = %loc(FRD_RMSOpen)
	         call lib$signal(FRD_RMSOpen,%val(2),in_file,%val(ios))
	      end if
	else
	    call lib$signal(%val(status))
	end if
c
c interpret rms file
c
        read (lun_samp,*) int_samp_hz
        read (lun_samp,*) mis_samp_hz

	if (int) then
           int_samp_hz(1) = int_samp_hz(1)
           int_samp_hz(2) = int_samp_hz(1)
           int_samp_hz(3) = 512.00
	else
           mis_samp_hz(1) = mis_samp_hz(1) 
	   mis_samp_hz(2) = mis_samp_hz(1)
           mis_samp_hz(3) = 512.00 
	end if
c
c  open output file
c
	status = lib$get_lun(lun)

	if (status .eq. ss$_normal) then

	open (unit=lun,name=out_file,status='new',form='unformatted',
     .			iostat=ios,access='direct',recl=514)

	if (ios .eq. 0) then

c
c  generate electronics transfer function
c
	dcgain = bessel_gain * fixed_gain
	nrec = 0
	do isampl=1,3				!  1,2=MTM modes, 3=Fakeit 
	   if (int) then
	       fsamp = int_samp_hz(isampl)      !  INT sampling rate
	   else
	       fsamp = mis_samp_hz(isampl)      !  Mission sampling rate
	   end if
	   do ichan=1,4				!  RH,RL,LH,LL channels
	   tauboost = tau(ichan)

	      do micro=1,2			!  1=dig fltr on, 2=off

		 do ncompress=1,12		!  adds per group
c
c  stop processing on error
c
		 if(status .eq. ss$_normal)then

		    nrec = nrec + 1
		    dfhz = fsamp/ncompress/512.
		    ampmax = -1.

		    do k=1,257
		       freqhz = (k-1) * dfhz
		       call bessel (freqhz, bes3db, zbesl)
		       call tboost (freqhz, tauboost, ztboost)
		       call dcblock (freqhz, zdcblock)
		       call digfltr (freqhz, micro, ichan, fsamp, zdigfil)
		       call compress (freqhz, ncompress, fsamp, zsmooth)

		       zanalog = zbesl * ztboost * zdcblock
		       zdigital = zdigfil * zsmooth

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c  The following two statements are the only difference between this 
c  program and ELEX_TRANSFCN.
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
		       dcgain = -1.
		       zanalog = (1.,0.)

		       zxfer = conjg (dcgain * zanalog * zdigital)

	   	       ampl = sqrt (real (zxfer * conjg (zxfer)))
	   	       ampmax = amax1 (ampl, ampmax)
	   	       if (ampl .lt. ampmax/1000.) then
	       		  ztrans(k) = 100000.
		       else
			  ztrans(k) = -zxfer
		       endif
		    enddo

!	   	    type *, nrec
	   	    write (lun, rec=nrec, iostat=ios) ztrans
			if(ios .ne. 0)then
			  call lib$signal(frd_rmswrite,%val(2),
	1			out_file,%val(ios))
			  status = %loc(frd_rmswrite)
			endif

	      endif	!status .ne. ss$_normal

		 enddo	!k=1,257
	      enddo	!ncompress
	   enddo	!micro
	enddo		!ichan

	if (status .ne. ss$_normal) call lib$signal(%val(status))

	close (lun, iostat=ios)
	if(ios .ne. 0) then
		status = %loc(frd_rmsclose)
		call lib$signal(frd_rmsclose,%val(2),out_file,%val(ios))
	endif

	else		!ios .eq. 0
		call lib$signal(frd_rmsopen,%val(2),out_file,%val(ios))
	endif		!ios .eq. 0

	status = lib$free_lun(lun)

	else		!ss$_normal
		call lib$signal(%val(status))
	endif		!ss$_normal

	if(status .eq. ss$_normal)then
		call lib$signal(frd_normal)
	else
		call lib$signal(%val(ss$_abort))
	endif

	stop
	end

	subroutine bessel (fhz, bes3db, zbesl)
	implicit complex*8 (z)
	zfb = cmplx (0.,fhz/bes3db)
	zfb2 = zfb * zfb
	zfb3 = zfb * zfb2
	zfb4 = zfb * zfb3
	zfb5 = zfb * zfb4
	zbesl = 1./(1. + 2.4275*zfb  + 2.6189*zfb2 + 1.5894*zfb3 + 
     .			 0.5511*zfb4 + 0.0892*zfb5)
	return
	end


	subroutine tboost (fhz, tau, ztboost)
	implicit complex*8 (z)
	ztboost = 1. + (0.,6.2831853)*fhz*tau
	return
	end


	subroutine dcblock (fhz, zdcblock)
	implicit complex*8 (z)
	data twopi/6.2831853/
	zs = (0.,3.2) * twopi * fhz
	zdcblock = (zs/(1. + zs))**5 * zs/(2. + zs)
	return
	end

	
	subroutine digfltr (freqhz, micromode, ichan, samplrate, zdigfil)
	implicit complex*8 (z)
	zi = cmplx(0.,-6.2831853)
	z = cexp (zi*freqhz/samplrate)
	zdigfil = 1.
	if (micromode .eq. 2) return
	if (ichan.eq.2 .or. ichan.eq.4) then
c	   zdigfil = (1. + z*z)**2/(8. - 12.5*z*z + 5.*z**4)/8.     !Low freq
	   zdigfil = ((1. + 2.*z*(1.+ z + z*z) + z**4)/
     .			(8. - 8.*z*z + z**4))/8.
	else
	   zdigfil = (1. + z)**2/(8. - 11.*z + 5.*z*z)/2.           !High freq
	endif
	return
	end


	subroutine compress  (fhz, ncompress, samplrate, zsmooth)
	implicit complex*8 (z)
	pif = 3.141592654  * fhz/samplrate
	zsmooth = 1.
	if (pif .lt. 0.001) return
	ampl = sin(pif*ncompress)/sin(pif)
	zphase = cmplx (0., pif*(1-ncompress))
	zsmooth = ampl/ncompress * cexp(zphase)
	return
	end
