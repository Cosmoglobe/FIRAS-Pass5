        Program FTB_Checksum

c-----------------------------------------------------------------------------
c
c	Program Name: FTB_Checksum
c
c	Program Description:
c               This program reads records from the FDQ_SDF channel dataset for
c               a specified time range to detect a setting of the Checksum Flag.
c		Two files may be generated by command line qualifiers for good 
c		and bad time flags. The information for good time tags goes in 
c		one file and bad time tags in the other. The transmit time, the
c		midpoint of collect time, the badtime flag and the telemetry 
c	        flag are dumped on a printline. 
c		Geocentric latitude and longitude are dumped in a format which 
c		can be read by an IDL program which plots the orbital path from
c		the terrestrial latitude and longitude on the science records or
c		obtained from the attitude files using the frame transmit time
c		and correlates the position with the SAA and VABs.
c	        If the checksum flag has a value other than zero, relevant 
c		information from the record is dumped along with the time tags. 
c
c	Author: Shirley M. Read
c		STX
c		December 1989
c
c	Calling sequence:
c		invoked from DCL
c
c	Include files:
c		$SSdef
c		Ct$Library:Ctuser.Inc
c
c	Input:
c		None
c
c	Output:
c		None
c
c-----------------------------------------------------------------------------
c
ch Change Log:
ch
c-----------------------------------------------------------------------------

	Implicit None

c	Include Files.

	Include 'CT$Library:CTUser.Inc'
	Include '($SSDef)'

c	Functions

	Integer*4 FTB_Parse_Checksum
     	Integer*4 FTB_Init_Check_Report
	Integer*4 FTB_Print_Sci_Info
	Integer*4 FTB_Print_BadSci_Info
	Integer*4 Lib$Get_Lun
	Integer*4 Str$Upcase

c	External Parameters.

	External FTB_Normal
	External FTB_Aberr
	External FTB_CTInit
	External FTB_CTOpen
	External FTB_CTRead
	External FTB_CTClos

	Integer*4 CT_Connect_Read
	External  CT_Connect_Read
	External  FUT_Error

c	Data Dictionary and Records.

	Dictionary 'NFS_SDF'
	Record / NFS_SDF / Sci_Rec	! FIRAS Raw Science records

c	Local Declarations.

	Integer*4  Status		! General program status
	Integer*4  Rstatus              ! Function return status
	Integer*4  Zero / 0 /
	Character*64 Filename           ! String to hold filename
	Character*10 Dataset_Name 
	Character*8  Dataset / 'FDQ_SDF_'/   ! CT Dataset Name
	Character*2 Channel             ! FIRAS channel -- RH, RL, LH, LL
	Character*14 Start, Stop        ! Data start and stop times
	Character*19 Archive / 'CSDR$FIRAS_ARCHIVE:' /
	Integer*2 CT_Status(20)         ! COBETRIEVE status
	Integer*4 Lun, GRpt_Lun, BRpt_Lun		! Logical units
	Logical*1 Eof / .False. /       ! End of file
	Integer*4  Ix                   ! Index
	Character*1 Type_Rpt            ! Type of checksum file output
        Logical*1 Checksum              ! Checksum flag
        Logical*1 Badtime               ! Badtime flag
	logical*1 Grpt / .False. /, Brpt / .False. /
	Character*1 Semi / ';' /
	Character*1 Slash / '/' /

c Establish the error handler and initialize.

	Call Lib$Establish ( Fut_Error )

	Status = SS$_Normal

c Parse command line.

	Rstatus = FTB_Parse_Checksum ( Channel, Start, Stop,
	1                        Type_Rpt, Checksum, Badtime )
	If ( Rstatus .NE. %loc(FTB_Normal) ) Then
	  Status = SS$_Abort
	Else
	  If ((Type_Rpt .EQ. 'G') .or. (Type_Rpt .EQ. 'T')) Then
	    Grpt = .True.
	  Endif
	  If ((Type_Rpt .EQ. 'B') .or. (Type_Rpt .EQ. 'T')) Then
	    Brpt = .True.
	  Endif
	Endif
	Dataset_Name = Dataset // Channel

c    Open report file and write initial information  

	If (Status .EQ. SS$_Normal) Then
	    Rstatus = FTB_Init_Check_Report ( Dataset_name,
	1   	     Channel, Start, Stop, Type_Rpt, Checksum, 
	2            Badtime, Status, GRpt, BRpt, GRpt_Lun, BRpt_Lun )
        Else
            If (Rstatus .NE. %loc(FTB_Normal)) then
                Status = SS$_Abort
    	    Endif
	Endif
 
c Initialize to COBETRIEVE.
	
	If ( Status .EQ. SS$_Normal ) Then
	  Call CT_Init ( CT_Status )
	  If (Ct_Status(1) .NE. 1 ) Then
	    Rstatus = Ct_Status(1)
	    Call Lib$Signal (FTB_CTInit, %val(1), %val(Rstatus))
	    Status = SS$_Abort
	  Endif
 	Endif

c Get a logical unit.

	Rstatus = Lib$Get_Lun ( Lun )
	If ( Rstatus .NE. SS$_Normal ) Then
	  Status = SS$_Abort
	Endif

c Open the File.

	If ( Status .EQ. SS$_Normal ) Then
	  Filename = Archive//Dataset_Name//Slash//Start//Semi//Stop//Semi
	  Open (Unit=Lun, File=Filename, Useropen=CT_Connect_Read,
	1	Status='OLD', Iostat=Rstatus )
	  If ( Rstatus .NE. Zero ) Then
	    Call Lib$Signal (FTB_CTOpen, %val(1), %val(Rstatus))
	    Status = SS$_Abort
	  Endif
	Endif

c Read and process the records.

	If ( Status .EQ. SS$_Normal ) Then
	      Eof = .False.
	      Do While ( .NOT. Eof ) 
	         Call CT_Read_Arcv ( ,Lun, Sci_Rec, CT_Status )
	         If (Ct_Status(1) .Eq. CTP_Endoffile) Then
	             Eof = .True.
	         ElseIf ( CT_Status(1) .NE. CTP_Normal ) Then
	             Status = SS$_Abort
	             Rstatus = CT_Status(1)
	             Call Lib$Signal (FTB_CTRead, %val(1), %val(Rstatus))
	             Eof = .True.
	         Endif
              If ( Checksum ) Then
	           If ((Status .EQ. SS$_Normal) .and. (.not. Eof)) Then
	              If (Sci_Rec.DQ_Data.Data_Quality(10) .Eq. Zero) Then
   		          ! Print valid checksum records
	                  If (Grpt) Then
		              Rstatus = FTB_Print_Sci_Info ( Channel, 
	1		      Sci_Rec, GRpt_Lun, Start, Stop )
	                      If ( Rstatus .NE. %loc(FTB_Normal)) Then
	                           Status = SS$_Abort
                              Endif
                          Endif
                      Else    ! Print Bad checksum records
  	                  If (Brpt) Then
		              Rstatus = FTB_Print_BadSci_Info ( Channel,
	1	              Sci_Rec, BRpt_Lun, Start, Stop )
	                      If ( Rstatus .NE. %loc(FTB_Normal)) Then
                                   Status = SS$_Abort
	                      Endif
                          Endif
                      Endif
                   Endif
              Else      !(Badtime) Qualifier
	           If ((Status .EQ. SS$_Normal) .and. (.not. Eof)) Then
	              If (Sci_Rec.Collect_Time.Badtime_Flag .Eq. Zero) Then
   		             ! Print Good Time Flag records
	                  If (Grpt) Then
		              Rstatus = FTB_Print_Sci_Info ( Channel, 
	1		      Sci_Rec, GRpt_Lun, Start, Stop )
	                      If ( Rstatus .NE. %loc(FTB_Normal)) Then
	                           Status = SS$_Abort
                              Endif
                          Endif
                      Else    ! Print Bad Time Flag records
  	                  If (Brpt) Then
		              Rstatus = FTB_Print_BadSci_Info ( Channel,
	1	              Sci_Rec, BRpt_Lun, Start, Stop )
	                      If ( Rstatus .NE. %loc(FTB_Normal)) Then
                                   Status = SS$_Abort
	                      Endif
                          Endif
                      Endif
                   Endif
              Endif
	      If ( Status .Eq. SS$_Abort ) Eof = .True.
	  Enddo 	!Do While ( .NOT. Eof ) 
 	Endif		! Status .EQ. SS$_Normal 

c Close the Archive.

	Call Ct_Close_Arcv( , Lun, Ct_Status)

c Exit with status.

	If ( Status .EQ. SS$_Normal ) Then
	  Call Lib$Signal(FTB_Normal)
	  Call Exit(Status)
	Else
	  Call Lib$Signal(FTB_Aberr)
	  Call Exit(Status)
	Endif	  
	End
